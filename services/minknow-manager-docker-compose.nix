{ name
, version
, minknowManagerDockerfile
, minknowDataDir
, minknowLogDir
, doradoSocket
, positionsPortStart
, managerPortStart
, expose
}:

{ config, pkgs, lib, ... }:

let
  containerName = "${name}-${version}";
  positionsPorts = lib.genList (i:
    let p = toString (positionsPortStart + i);
    in "${p}:${p}/tcp"
  ) 8;
  managerPorts = lib.genList (i:
    let p = toString (managerPortStart + i);
    in "${p}:${p}/tcp"
  ) 5;
  doradoSocketDir = lib.dirOf doradoSocket;
in
{
  # Containers
  virtualisation.oci-containers.containers."${containerName}" = {
    image = "${containerName}-pre";
    bindMounts = lib.mkMerge [
      {
        "/dev/bus/usb" = {
          hostPath = "/dev/bus/usb";
          isReadOnly = false;
        };
        "/run/udev" = {
          hostPath = "/run/udev";
          isReadOnly = true;
        };
        "${minknowDataDir}" = {
          hostPath = "/var/lib/minknow/data";
          isReadOnly = false;
        };
        "${minknowLogDir}" = {
          hostPath = "/var/log/minknow";
          isReadOnly = false;
        };
        "${doradoSocketDir}" = {
          hostPath = "/tmp/.guppy";
          isReadOnly = false;
        };
      }
      (lib.mkIf expose {
        "/tmp" = {
          hostPath = "/tmp";
          isReadOnly = true;
        };
      })
    ];
    ports = positionsPorts ++ managerPorts;
    log-driver = "journald";
    extraOptions = [
      "--device-cgroup-rule=c 189:* rmw"
      "--network-alias=${containerName}"
      "--network=${containerName}_default"
    ];
  };

  systemd.tmpfiles.rules = [
    "d ${minknowLogDir} 0775 minknowuser01 minknowuser01 -"
    "d ${minknowDataDir} 0775 minknowuser01 minknowuser01 -"
    "d ${minknowDataDir}/data 0775 minknowuser01 minknowuser01 -"
  ];

  systemd.services."docker-${containerName}" = {
    serviceConfig = {
      Restart = lib.mkOverride 90 "no";
    };
    after = [
      "docker-network-${containerName}_default.service"
      "docker-build-${containerName}.service"
    ];
    requires = [
      "docker-network-${containerName}_default.service"
    ];
    partOf = [
      "docker-compose-${containerName}-root.target"
    ];
    wantedBy = [
      "docker-compose-${containerName}-root.target"
    ];
  };

  # Networks
  systemd.services."docker-network-${containerName}_default" = {
    path = [ pkgs.docker_26 ];
    serviceConfig = {
      Type = "oneshot";
      RemainAfterExit = true;
      ExecStop = "docker network rm -f ${containerName}_default";
    };
    script = ''
      docker network inspect ${containerName}_default || docker network create ${containerName}_default
    '';
    partOf = [ "docker-compose-${containerName}-root.target" ];
    wantedBy = [ "docker-compose-${containerName}-root.target" ];
  };

  # Builds
  systemd.services."docker-build-${containerName}" =
    {
      path = [ pkgs.docker_26 pkgs.git ];
      serviceConfig = {
        Type = "oneshot";
        TimeoutSec = 300;
      };
      script = ''
          docker build -t ${containerName}-pre . -f ${minknowManagerDockerfile}
        '';
    };

  # Root service
  # When started, this will automatically create all resources and start
  # the containers. When stopped, this will teardown all resources.
  systemd.targets."docker-compose-${containerName}-root" = {
    unitConfig = {
      Description = "Root target is a modified version of the original generated by compose2nix.";
    };
    wantedBy = [ "multi-user.target" ];
  };
}
